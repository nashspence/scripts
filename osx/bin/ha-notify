#!/bin/sh
# Send a notification to Home Assistant via its REST API.
# Usage: ha-notify.sh [-s service] [-d json-data] <title> <message>

set -eu

svc=notify
data=

usage() {
    printf 'Usage: %s [-s service] [-d json-data] <title> <message>\n' "${0##*/}" >&2
    exit 2
}

# Parse flags (POSIX getopts)
while getopts 's:d:h' opt; do
    case "$opt" in
        s) svc=$OPTARG ;;
        d) data=$OPTARG ;;
        h|\?) usage ;;
    esac
done
shift "$((OPTIND - 1))"

title=${1:-}
msg=${2:-}
[ -n "$title" ] && [ -n "$msg" ] || usage

# Minimal JSON string escaper (quotes + backslashes only)
esc() {
    printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

etitle=$(esc "$title")
emsg=$(esc "$msg")

body='{"title":"'"$etitle"'","message":"'"$emsg"'"'
[ -n "${data:-}" ] && body="$body"',"data":'"$data"
body="$body"'}'

# Keychain fetchers
get_token() {
    security find-generic-password -s com.nashspence.scripts.homeassistant.lltoken -w 2>/dev/null || :
}
get_url() {
    security find-generic-password -s com.nashspence.scripts.homeassistant.host -w 2>/dev/null || :
}

# Ensure sensitive vars are wiped on exit or interruption
cleanup_secrets() {
    token=''
    ha_url=''
    unset token ha_url || :
}
trap cleanup_secrets 0 HUP INT TERM

# Fetch secrets at the last possible moment
token=$(get_token)
ha_url=$(get_url)

[ -n "${token:-}" ] || { printf 'Error: no token in Keychain\n' >&2; exit 1; }
[ -n "${ha_url:-}" ] || { printf 'Error: no URL in Keychain\n' >&2; exit 1; }

# Normalize trailing slash on URL
case "$ha_url" in
    */) ha_url=${ha_url%/} ;;
esac

# Use curl config from stdin so secrets are not exposed in process list
{
    curl -fSs --config - \
        -H "Content-Type: application/json" \
        --data "$body" \
        "$ha_url/api/services/notify/$svc" >/dev/null
} <<EOF
header = "Authorization: Bearer $token"
EOF

cleanup_secrets