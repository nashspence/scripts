#!/bin/sh
# Send a notification to Home Assistant via its REST API.
# Usage: ha-notify <service|*> <title> <message> [json-data]

set -eu

usage() {
    printf 'Usage: %s <service|*> <title> <message> [json-data]\n' "${0##*/}" >&2
    exit 2
}

svc=${1:-}
title=${2:-}
msg=${3:-}
data=${4:-}

[ -n "$svc" ] && [ -n "$title" ] && [ -n "$msg" ] || usage

[ "$svc" = "*" ] && svc=notify

# Minimal JSON string escaper (quotes + backslashes only)
esc() {
    printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

etitle=$(esc "$title")
emsg=$(esc "$msg")

body='{"title":"'"$etitle"'","message":"'"$emsg"'"'
[ -n "${data:-}" ] && body="$body"',"data":'"$data"
body="$body"'}'

# Keychain fetchers
get_token() {
    security find-generic-password -s com.nashspence.scripts.homeassistant.lltoken -w 2>/dev/null || :
}
get_url() {
    security find-generic-password -s com.nashspence.scripts.homeassistant.host -w 2>/dev/null || :
}

# Ensure sensitive vars are wiped on exit or interruption
cleanup_secrets() {
    token=''
    ha_url=''
    unset token ha_url || :
}
trap cleanup_secrets 0 HUP INT TERM

# Fetch secrets at the last possible moment
token=$(get_token)
ha_url=$(get_url)

[ -n "${token:-}" ] || { printf 'Error: no token in Keychain\n' >&2; exit 1; }
[ -n "${ha_url:-}" ] || { printf 'Error: no URL in Keychain\n' >&2; exit 1; }

# Normalize trailing slash on URL
case "$ha_url" in
    */) ha_url=${ha_url%/} ;;
esac

# Use curl config from stdin so secrets are not exposed in process list
{
    curl -fSs --config - \
        -H "Content-Type: application/json" \
        --data "$body" \
        "$ha_url/api/services/notify/$svc" >/dev/null
} <<EOF
header = "Authorization: Bearer $token"
EOF

cleanup_secrets
