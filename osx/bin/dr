#!/bin/zsh
# dr â€” build (Podman) and run a Containerfile/Dockerfile; pipe-friendly.

set -euo pipefail

DR_MACHINE="${DR_MACHINE:-${MACHINE:-com.nashspence.pmachine.script}}"
DR_IMAGE_PREFIX="${DR_IMAGE_PREFIX:-com.nashspence.pmachine.script.}"
DR_TAG="${DR_TAG:-latest}"
WAKER_LABEL="${WAKER_LABEL:-com.nashspence.pmachine.script.waker}"

file="Containerfile"
if [[ -n "${1:-}" && -f "$1" ]]; then file="$1"; shift; fi
[[ -f "$file" ]] || { print -u2 "dr: file not found: $file"; exit 1; }

SOCK="${PMACHINE_SOCK:-/tmp/pmachine.${UID}.sock}"

typeset -gi DR_SOCK_FD=-1
_close_sock_fd() { (( DR_SOCK_FD >= 0 )) && exec {DR_SOCK_FD}>&- 2>/dev/null || true; }
# IMPORTANT: only close on EXIT (not on INT/TERM), so Ctrl-C doesn't drop the hold early.
trap _close_sock_fd EXIT

hold_socket_open() {
  # Create socket (via waker) if needed
  [[ -S "$SOCK" ]] || launchctl kickstart -kp "gui/$(id -u)/${WAKER_LABEL}" >/dev/null 2>&1 || true

  # Open connected UNIX socket and duplicate as CLOEXEC so children can't inherit it.
  if zmodload zsh/net/socket 2>/dev/null; then
    # wait briefly for the socket to appear
    local deadline=$((SECONDS + ${DR_SOCKET_WAIT_SECS:-3}))
    while [[ ! -S "$SOCK" && $SECONDS -lt $deadline ]]; do sleep 0.1; done
    if [[ -S "$SOCK" ]] && zsocket "$SOCK" 2>/dev/null; then
      local rawfd="$REPLY"
      if zmodload zsh/system 2>/dev/null && sysopen -r -o cloexec -u DR_SOCK_FD "/dev/fd/$rawfd" 2>/dev/null; then
        exec {rawfd}>&- 2>/dev/null || true   # drop non-cloexec original
      else
        # fallback: keep original (children may inherit if we ever exec; we won't)
        DR_SOCK_FD="$rawfd"
      fi
      return 0
    fi
  fi

  # Last resort: just poke the agent (no hold). We still proceed.
  launchctl kickstart -kp "gui/$(id -u)/${WAKER_LABEL}" >/dev/null 2>&1 || true
  return 0
}
hold_socket_open

wait_podman() {
  local timeout="${DR_WAIT_SECS:-90}" start now; start="$(date +%s)"
  while :; do
    podman --connection "$DR_MACHINE" info >/dev/null 2>&1 && return 0
    sleep 0.5
    now="$(date +%s)"
    (( now - start >= timeout )) && { print -u2 "dr: timed out waiting for Podman '$DR_MACHINE'"; exit 2; }
  done
}
wait_podman

slugify(){ local s="${1:l}"; s="${s//[^a-z0-9._-]/-}"; s="${s##-}"; s="${s%%-}"; print -r -- "$s"; }
wrapper="${DR_WRAPPER_NAME:-}"
if [[ -z "$wrapper" ]]; then
  dir="$(cd "$(dirname "$file")" && pwd)"; base="${file:t}"
  case "${base:l}" in
    containerfile|dockerfile) wrapper="${dir:t}" ;;
    *) wrapper="$base"
       wrapper="${wrapper%.Containerfile}"; wrapper="${wrapper%.containerfile}"
       wrapper="${wrapper%.Dockerfile}";    wrapper="${wrapper%.dockerfile}"
       wrapper="${wrapper%.*}"
       [[ -z "$wrapper" ]] && wrapper="${dir:t}" ;;
  esac
fi
wrapper="$(slugify "$wrapper")"
repo="$(slugify "${DR_IMAGE_PREFIX}${wrapper}")"
image="${repo}:${DR_TAG}"

pull_flag=()
if [[ -z "${DR_NO_PULL:-}" ]]; then
  case "${DR_PULL_MODE:-yes}" in
    always) pull_flag=(--pull-always) ;;
    never)  pull_flag=(--pull-never)  ;;
    *)      pull_flag=(--pull) ;;
  esac
fi
dir="$(cd "$(dirname "$file")" && pwd)"
podman --connection "$DR_MACHINE" build "${pull_flag[@]}" -f "$file" -t "$image" "$dir"

run_flags=(-i)
if [[ -t 0 && -z "${DR_STDIN_PIPE:-}" ]]; then
  run_flags=(-it)
elif [[ -z "${DR_NO_TTY:-}" ]]; then
  run_flags+=(-t)
fi
env_flags=()
if [[ ! -t 1 && -z "${DR_NO_UNBUFFER:-}" ]]; then
  env_flags+=(-e PYTHONUNBUFFERED=1 -e PYTHONIOENCODING=UTF-8)
fi

typeset -a run_extra cmd_args; run_extra=()
while (( $# )); do
  if [[ "$1" == "--" ]]; then shift; break; fi
  run_extra+=("$1"); shift
done
cmd_args=("$@")

if (( ${#cmd_args[@]} == 0 )); then
  integer _anyflag=0
  for _a in "${run_extra[@]}"; do [[ "$_a" == -* ]] && { _anyflag=1; break; }; done
  (( !_anyflag )) && { cmd_args=("${run_extra[@]}"); run_extra=(); }
fi

# Do NOT exec; keep this shell alive to hold the socket FD.
set +e
podman --connection "$DR_MACHINE" run --rm \
  "${run_flags[@]}" "${env_flags[@]}" "${run_extra[@]}" \
  "$image" "${cmd_args[@]}"
rc=$?
set -e

exit $rc