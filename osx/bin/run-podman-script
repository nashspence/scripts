#!/bin/zsh
# run-podman-script â€” build (Podman) and run a Containerfile/Dockerfile; pipe-friendly.
# Logs (stderr only): (1) waiting for connection, (2) chosen image + why, (3) exact run command.

set -euo pipefail

# ----- minimal logging (stderr only) -----------------------------------------------------------
log()  { print -u2 -- "$*"; }
fail() { print -u2 -- "ERROR: $*"; }

# ----- config ----------------------------------------------------------------------------------
DR_MACHINE="${DR_MACHINE:-${MACHINE:-com.nashspence.scripts}}"
DR_IMAGE_PREFIX="${DR_IMAGE_PREFIX:-com.nashspence.scripts.}"
DR_TAG="${DR_TAG:-latest}"
WAKER_LABEL="${WAKER_LABEL:-com.nashspence.scripts.agent}"
SOCK="${PODMAN_SCRIPTS_SOCK:-/tmp/com.nashspence.scripts.${UID}.sock}"

# input: file/dir and optional release.yaml
file="Containerfile"
if [[ -n "${1:-}" ]]; then
  if [[ -f "$1" && "${1:t}" != "release.yaml" ]]; then
    file="$1"; shift
  elif [[ -d "$1" ]]; then
    file="$1/Containerfile"; shift
  fi
fi
release_yaml=""
if [[ -n "${1:-}" && -f "$1" && "${1:t}" == "release.yaml" ]]; then
  release_yaml="$1"; shift
fi
[[ -f "$file" ]] || { fail "file not found: $file"; exit 1; }

# ----- hold the launchd socket for our entire lifetime (silent best-effort) --------------------
typeset -gi DR_SOCK_FD=-1
_close_sock_fd() { (( DR_SOCK_FD >= 0 )) && exec {DR_SOCK_FD}>&- 2>/dev/null || true; }
trap _close_sock_fd EXIT   # covers early exits / exec failure paths

# when you create the socket FD:
if zmodload zsh/net/socket 2>/dev/null && zsocket "$SOCK" 2>/dev/null; then
  DR_SOCK_FD=$REPLY
  if zmodload zsh/system 2>/dev/null; then
    zsystem fdflags -s cloexec $DR_SOCK_FD 2>/dev/null || true
  fi
fi

# ----- wait for podman connection (1) ----------------------------------------------------------
wait_podman() {
  local timeout="${DR_WAIT_SECS:-90}" start now; start="$(date +%s)"
  log "waiting for podman connection '${DR_MACHINE}' (timeout ${timeout}s)"
  while :; do
    if podman --connection "$DR_MACHINE" info >/dev/null 2>&1; then
      return 0
    fi
    sleep 0.5
    now="$(date +%s)"
    (( now - start >= timeout )) && { fail "timed out waiting for Podman '${DR_MACHINE}'"; exit 2; }
  done
}
wait_podman

# ----- helpers ---------------------------------------------------------------------------------
slugify(){ local s="${1:l}"; s="${s//[^a-z0-9._-]/-}"; s="${s##-}"; s="${s%%-}"; print -r -- "$s"; }
yaml_get_key() {
  local key="$1" yfile="$2"
  awk -v k="$key" '
    $0 ~ "^[[:space:]]*"k":" {
      sub("^[[:space:]]*"k":[[:space:]]*", "", $0)
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", $0)
      gsub(/^"[[:space:]]*|"[[:space:]]*$/,"",$0)
      gsub(/^'\''[[:space:]]*|'\''[[:space:]]*$/,"",$0)
      print $0
      exit 0
    }' "$yfile" 2>/dev/null || true
}
is_not_found_err() {
  local msg="${1:l}"
  [[ "$msg" == *"manifest unknown"* || "$msg" == *"not found"* || "$msg" == *"no such image"* || "$msg" == *"unknown blob"* || "$msg" == *"error locating image"* ]]
}

# ----- derive image/tag ------------------------------------------------------------------------
wrapper="${DR_WRAPPER_NAME:-}"
if [[ -z "$wrapper" ]]; then
  dir="$(cd "$(dirname "$file")" && pwd)"; base="${file:t}"
  case "${base:l}" in
    containerfile|dockerfile) wrapper="${dir:t}" ;;
    *) wrapper="$base"
       wrapper="${wrapper%.Containerfile}"; wrapper="${wrapper%.containerfile}"
       wrapper="${wrapper%.Dockerfile}";    wrapper="${wrapper%.dockerfile}"
       wrapper="${wrapper%.*}"
       [[ -z "$wrapper" ]] && wrapper="${dir:t}" ;;
  esac
fi
wrapper="$(slugify "$wrapper")"
repo="$(slugify "${DR_IMAGE_PREFIX}${wrapper}")"
local_image="${repo}:${DR_TAG}"
image="$local_image"

pull_flag=()
if [[ -z "${DR_NO_PULL:-}" ]]; then
  case "${DR_PULL_MODE:-yes}" in
    always) pull_flag=(--pull-always) ;;
    never)  pull_flag=(--pull-never)  ;;
    *)      pull_flag=(--pull) ;;
  esac
fi
dir="$(cd "$(dirname "$file")" && pwd)"

# ----- choose release image vs build -----------------------------------------------------------
build_needed=1
image_reason="built locally from '${file}'"
if [[ -n "$release_yaml" && -z "${DR_NO_PULL:-}" ]]; then
  rel_img="$(yaml_get_key image "$release_yaml")"
  rel_ver="$(yaml_get_key version "$release_yaml")"
  if [[ -n "$rel_img" && -n "$rel_ver" ]]; then
    rel_ref="${rel_img}:${rel_ver}"
    set +e
    pull_err="$({ podman --connection "$DR_MACHINE" pull "$rel_ref" 1>/dev/null; } 2>&1)"; pull_rc=$?
    set -e
    if (( pull_rc == 0 )); then
      image="$rel_ref"
      build_needed=0
      image_reason="release available"
    else
      if is_not_found_err "$pull_err"; then
        build_needed=1
      else
        fail "failed to pull ${rel_ref} (rc=${pull_rc}). Details follow:"; print -u2 -- "$pull_err"; exit $pull_rc
      fi
    fi
  fi
fi

if (( build_needed )); then
  set +e
  podman --connection "$DR_MACHINE" build "${pull_flag[@]}" -f "$file" -t "$local_image" "$dir"
  build_rc=$?
  set -e
  if (( build_rc != 0 )); then fail "build failed (rc=$build_rc) for '${local_image}' from '${file}' (context '${dir}')"; exit $build_rc; fi
  image="$local_image"
  image_reason="built locally from '${file}'"
fi

# ----- run -------------------------------------------------------------------------------------
run_flags=(-i)
if [[ -t 0 && -z "${DR_STDIN_PIPE:-}" ]]; then run_flags=(-it)
elif [[ -z "${DR_NO_TTY:-}" ]]; then run_flags+=(-t); fi

env_flags=()
if [[ ! -t 1 && -z "${DR_NO_UNBUFFER:-}" ]]; then env_flags+=(-e PYTHONUNBUFFERED=1 -e PYTHONIOENCODING=UTF-8); fi

typeset -a run_extra cmd_args; run_extra=()
while (( $# )); do if [[ "$1" == "--" ]]; then shift; break; fi; run_extra+=("$1"); shift; done
cmd_args=("$@")
if (( ${#cmd_args[@]} == 0 )); then integer _anyflag=0; for _a in "${run_extra[@]}"; do [[ "$_a" == -* ]] && { _anyflag=1; break; }; done; (( !_anyflag )) && { cmd_args=("${run_extra[@]}"); run_extra=(); }; fi

# (2) minimal image description
log "${image_reason} -> using ${image}"

# Compose exact command and log it (3)
fullcmd=(podman --connection "$DR_MACHINE" run --rm "${run_flags[@]}" "${env_flags[@]}" "${run_extra[@]}" "$image" "${cmd_args[@]}")
log "${(j: :)${(q)fullcmd}}"

# Execute
set +e
exec "${fullcmd[@]}"
rc=$?
set -e
exit $rc
