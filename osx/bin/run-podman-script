#!/bin/zsh
# run-podman-script â€” build (Podman) and run a Containerfile/Dockerfile; pipe-friendly.
# Logs (stderr only): (1) waiting for connection, (2) chosen image + why, (3) exact run command.

set -euo pipefail

# ----- minimal logging (stderr only) -----------------------------------------------------------
log()  { print -u2 -- "$*"; }
fail() { print -u2 -- "ERROR: $*"; }

# ----- config ----------------------------------------------------------------------------------
DR_MACHINE="${DR_MACHINE:-${MACHINE:-com.nashspence.scripts}}"
DR_IMAGE_PREFIX="${DR_IMAGE_PREFIX:-com.nashspence.scripts.}"
DR_TAG="${DR_TAG:-latest}"
WAKER_LABEL="${WAKER_LABEL:-com.nashspence.scripts.agent}"
SOCK="${PODMAN_SCRIPTS_SOCK:-/tmp/com.nashspence.scripts.${UID}.sock}"

# input flags
file=""
release_yaml=""

typeset -a run_extra cmd_args
run_extra=()
while (( $# )); do
  case "$1" in
    -f|--file)
      file="$2"; shift 2 ;;
    -r|--release)
      release_yaml="$2"; shift 2 ;;
    --)
      shift; break ;;
    *)
      run_extra+=("$1"); shift ;;
  esac
done
cmd_args=("$@")
if (( ${#cmd_args[@]} == 0 )); then
  integer _anyflag=0
  for _a in "${run_extra[@]}"; do [[ "$_a" == -* ]] && { _anyflag=1; break; }; done
  (( !_anyflag )) && { cmd_args=("${run_extra[@]}"); run_extra=(); }
fi

if [[ -z "$file" && -z "$release_yaml" ]]; then
  fail "missing --file or --release"; exit 1
fi

if [[ -n "$file" && -d "$file" ]]; then
  file="$file/Containerfile"
fi

if [[ -n "$file" && ! -f "$file" ]]; then
  fail "file not found: $file"; exit 1
fi

if [[ -n "$release_yaml" && ! -f "$release_yaml" ]]; then
  fail "file not found: $release_yaml"; exit 1
fi

if [[ -z "$file" && -n "$release_yaml" ]]; then
  file="$release_yaml"
fi

# ----- hold the launchd socket for our entire lifetime (silent best-effort) --------------------
typeset -gi DR_SOCK_FD=-1
_close_sock_fd() { (( DR_SOCK_FD >= 0 )) && exec {DR_SOCK_FD}>&- 2>/dev/null || true; }
trap _close_sock_fd EXIT   # covers early exits / exec failure paths

# when you create the socket FD:
if zmodload zsh/net/socket 2>/dev/null && zsocket "$SOCK" 2>/dev/null; then
  DR_SOCK_FD=$REPLY
  if zmodload zsh/system 2>/dev/null; then
    zsystem fdflags -s cloexec $DR_SOCK_FD 2>/dev/null || true
  fi
fi

# ----- wait for podman connection (1) ----------------------------------------------------------
wait_podman() {
  local timeout="${DR_WAIT_SECS:-90}" start now; start="$(date +%s)"
  log "waiting for podman connection '${DR_MACHINE}' (timeout ${timeout}s)"
  while :; do
    if podman --connection "$DR_MACHINE" info >/dev/null 2>&1; then
      return 0
    fi
    sleep 0.5
    now="$(date +%s)"
    (( now - start >= timeout )) && { fail "timed out waiting for Podman '${DR_MACHINE}'"; exit 2; }
  done
}
wait_podman

# ----- helpers ---------------------------------------------------------------------------------
slugify(){ local s="${1:l}"; s="${s//[^a-z0-9._-]/-}"; s="${s##-}"; s="${s%%-}"; print -r -- "$s"; }
yaml_get_key() {
  local key="$1" yfile="$2"
  awk -v k="$key" '
    $0 ~ "^[[:space:]]*"k":" {
      sub("^[[:space:]]*"k":[[:space:]]*", "", $0)
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", $0)
      gsub(/^"[[:space:]]*|"[[:space:]]*$/,"",$0)
      gsub(/^'\''[[:space:]]*|'\''[[:space:]]*$/,"",$0)
      print $0
      exit 0
    }' "$yfile" 2>/dev/null || true
}
is_not_found_err() {
  local msg="${1:l}"
  [[ "$msg" == *"manifest unknown"* || "$msg" == *"not found"* || "$msg" == *"no such image"* || "$msg" == *"unknown blob"* || "$msg" == *"error locating image"* ]]
}

# ----- derive image/tag ------------------------------------------------------------------------
wrapper="${DR_WRAPPER_NAME:-}"
if [[ -z "$wrapper" ]]; then
  dir="$(cd "$(dirname "$file")" && pwd)"; base="${file:t}"
  case "${base:l}" in
    containerfile|dockerfile|release.yaml) wrapper="${dir:t}" ;;
    *) wrapper="$base"
       wrapper="${wrapper%.Containerfile}"; wrapper="${wrapper%.containerfile}"
       wrapper="${wrapper%.Dockerfile}";    wrapper="${wrapper%.dockerfile}"
       wrapper="${wrapper%.*}"
       [[ -z "$wrapper" ]] && wrapper="${dir:t}" ;;
  esac
fi
wrapper="$(slugify "$wrapper")"
repo="$(slugify "${DR_IMAGE_PREFIX}${wrapper}")"
local_image="${repo}:${DR_TAG}"
image="$local_image"

pull_flag=()
if [[ -z "${DR_NO_PULL:-}" ]]; then
  case "${DR_PULL_MODE:-yes}" in
    always) pull_flag=(--pull-always) ;;
    never)  pull_flag=(--pull-never)  ;;
    *)      pull_flag=(--pull) ;;
  esac
fi
dir="$(cd "$(dirname "$file")" && pwd)"

# ----- choose release image vs build -----------------------------------------------------------
has_containerfile=1
if [[ "$file" == "$release_yaml" ]]; then
  has_containerfile=0
fi

build_needed=$has_containerfile
image_reason="built locally from '${file}'"
if [[ -n "$release_yaml" && -z "${DR_NO_PULL:-}" ]]; then
  rel_img="$(yaml_get_key image "$release_yaml")"
  rel_ver="$(yaml_get_key version "$release_yaml")"
  if [[ -n "$rel_img" && -n "$rel_ver" ]]; then
    rel_ref="${rel_img}:${rel_ver}"
    set +e
    pull_err="$({ podman --connection "$DR_MACHINE" pull "$rel_ref" 1>/dev/null; } 2>&1)"; pull_rc=$?
    set -e
    if (( pull_rc == 0 )); then
      image="$rel_ref"
      build_needed=0
      image_reason="release available"
    else
      if is_not_found_err "$pull_err"; then
        if (( has_containerfile )); then
          build_needed=1
        else
          fail "failed to pull ${rel_ref} (rc=${pull_rc})"; print -u2 -- "$pull_err"; exit $pull_rc
        fi
      else
        fail "failed to pull ${rel_ref} (rc=${pull_rc}). Details follow:"; print -u2 -- "$pull_err"; exit $pull_rc
      fi
    fi
  fi
fi

if (( build_needed )); then
  if (( has_containerfile )); then
    set +e
    podman --connection "$DR_MACHINE" build "${pull_flag[@]}" -f "$file" -t "$local_image" "$dir"
    build_rc=$?
    set -e
    if (( build_rc != 0 )); then fail "build failed (rc=$build_rc) for '${local_image}' from '${file}' (context '${dir}')"; exit $build_rc; fi
    image="$local_image"
    image_reason="built locally from '${file}'"
  else
    fail "no release image available and no Containerfile to build"; exit 1
  fi
fi

# ----- run -------------------------------------------------------------------------------------
run_flags=(-i)
if [[ -t 0 && -z "${DR_STDIN_PIPE:-}" ]]; then run_flags=(-it)
elif [[ -z "${DR_NO_TTY:-}" ]]; then run_flags+=(-t); fi

env_flags=()
if [[ ! -t 1 && -z "${DR_NO_UNBUFFER:-}" ]]; then env_flags+=(-e PYTHONUNBUFFERED=1 -e PYTHONIOENCODING=UTF-8); fi

# run flags and command arguments have been parsed above

# (2) minimal image description
log "${image_reason} -> using ${image}"

# Compose exact command and log it (3)
fullcmd=(podman --connection "$DR_MACHINE" run --rm "${run_flags[@]}" "${env_flags[@]}" "${run_extra[@]}" "$image" "${cmd_args[@]}")
log "${(j: :)${(q)fullcmd}}"

# ----- execute with signal translation (INT then KILL) ----------------------------------------
setopt TRAPS_ASYNC        # run traps even while waiting
typeset -gi _child=0

_term_forwarder() {
  # prevent reentry
  trap - TERM INT HUP
  if (( _child > 0 )); then
    /bin/kill -s INT  "$_child" 2>/dev/null || true
    sleep ${DR_TERM_GRACE:-0.3}
    /bin/kill -s KILL "$_child" 2>/dev/null || true
  fi
  exit 143
}

trap _term_forwarder TERM HUP
trap _term_forwarder INT   # keep Ctrl-C behavior consistent

set +e
"${fullcmd[@]}" & _child=$!
wait "$_child"; rc=$?
set -e
exit $rc
