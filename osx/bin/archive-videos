#!/bin/zsh
set -euo pipefail
setopt TRAPS_ASYNC   # run traps promptly even while a foreground cmd is running

source "$HOME/.config/podman-scripts/shortcuts_path.zsh"

INPUT="${1:-}"
if [[ -z "$INPUT" ]]; then
  print -u2 -- "no input file path provided"
  exit 2
fi

NOW=$(date +%Y%m%dT%H%M%S)
OUT="$HOME/Pipelines/Archive Videos/$NOW"
STAGE_OUT="$OUT/stage"
VCRUNCH_OUT="$OUT/vcrunch"
MKISO_OUT="$OUT/mkiso"
QCUT_OUT="$OUT/qcut"
mkdir -p "$STAGE_OUT" "$VCRUNCH_OUT" "$MKISO_OUT" "$QCUT_OUT"

# Graceful podman-friendly shutdown on SIGTERM (143); give children a chance to exit cleanly
trap '
  trap - TERM
  pkill -INT -P $$ 2>/dev/null || true
  sleep 0.3
  pkill -KILL -P $$ 2>/dev/null || true
  exit 143
' TERM

# Keep the Mac awake while we run; this exits automatically when $$ exits.
caffeinate -dims -w $$ &

# Sequential steps
stage   -v "${INPUT}:/in"     -v "${STAGE_OUT}:/out"
vcrunch -v "${STAGE_OUT}:/in" -v "${VCRUNCH_OUT}:/out"

# Parallel steps
mkiso -v "${VCRUNCH_OUT}:/in" -v "${MKISO_OUT}:/out" -- --out-file "$NOW.iso" &
mkiso_pid=$!
qcut  -v "${STAGE_OUT}:/in"   -v "${QCUT_OUT}:/out" &
qcut_pid=$!

# Wait for mkiso first; if it fails, kill qcut and exit with mkiso's code
if ! wait "$mkiso_pid"; then
  rc=$?
  kill "$qcut_pid" 2>/dev/null || true
  wait "$qcut_pid" 2>/dev/null || true
  exit $rc
fi

# Burn the ISO; on failure, also kill qcut
if ! burniso -v "${MKISO_OUT}/${NOW}.iso"; then
  rc=$?
  kill "$qcut_pid" 2>/dev/null || true
  wait "$qcut_pid" 2>/dev/null || true
  exit $rc
fi

# Let qcut finish; propagate its status
wait "$qcut_pid"

print -r -- "[$(date -u +%FT%TZ)] done"