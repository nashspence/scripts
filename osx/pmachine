#!/bin/zsh
# pmachine: install / uninstall activation + wrapper tooling + brew/podman/machine (pure zsh)
# Usage:
#   ./pmachine                 # Install everything (activation + wrappers + links + brew/podman/machine)
#   ./pmachine --uninstall     # Remove EVERYTHING this script installed (incl. Podman machine)

set -euo pipefail
emulate -L zsh
setopt err_return pipefail null_glob extended_glob

SCRIPT_PATH="${(%):-%N}"
SCRIPT_DIR="${SCRIPT_PATH:A:h}"

# ---- Config (overridable by env) -------------------------------------------------
BIN="${BIN:-$HOME/bin}"
REPO_DIR="${REPO_DIR:-${SCRIPT_DIR:h}}"
WRAPPERS_DIR="${WRAPPERS_DIR:-${REPO_DIR}/.wrappers}"
FILES_DIR="${FILES_DIR:-$REPO_DIR}"
LA_DIR="$HOME/Library/LaunchAgents"
UID_NUM="$(id -u)"
OSXBIN_DIR="${SCRIPT_DIR}/bin"   # REQUIRED (must contain 'dr')
MANIFEST="${WRAPPERS_DIR}/.symlinks-manifest"

MACHINE="${MACHINE:-com.nashspence.pmachine.script}"
PODMAN_CPUS="${PODMAN_CPUS:-10}"
PODMAN_MEM="${PODMAN_MEM:-18432}"
PODMAN_DISK="${PODMAN_DISK:-100}"

# ---- Labels / plists -------------------------------------------------------------
LABEL_WAKER="com.nashspence.pmachine.script.waker"
PLIST_WAKER_SRC="${SCRIPT_DIR}/${LABEL_WAKER}.plist"
PLIST_WAKER_DST="${LA_DIR}/${LABEL_WAKER}.plist"

# ---- PATH block markers ----------------------------------------------------------
PATH_BEGIN_MARK="# >>> pmachine PATH >>>"
PATH_END_MARK="# <<< pmachine PATH <<<"
PATH_EXPORT_LINE='export PATH="$HOME/bin:$PATH"'
SHORTCUTS_SNIPPET="$HOME/.config/pmachine/shortcuts_path.zsh"

# ---- Helpers ---------------------------------------------------------------------
die() { print -u2 -- "ERROR: $*"; exit 1; }
rehash_safely() { rehash 2>/dev/null || hash -r 2>/dev/null || true; }

add_path_block() {
  local file="$1"
  [[ -f "$file" ]] || : > "$file"
  if ! grep -Fqx -- "$PATH_BEGIN_MARK" "$file" 2>/dev/null; then
    {
      printf '\n%s\n' "$PATH_BEGIN_MARK"
      printf '%s\n' "$PATH_EXPORT_LINE"
      printf '%s\n' "$PATH_END_MARK"
    } >> "$file"
    echo "  + added PATH block to ${file##$HOME/}"
  fi
}

remove_path_block() {
  local file="$1"
  [[ -f "$file" ]] || return 0
  sed -E -i '' "/$(printf '%s' "$PATH_BEGIN_MARK" | sed 's/[^^]/[&]/g; s/\^/\\^/g')/,/$(printf '%s' "$PATH_END_MARK" | sed 's/[^^]/[&]/g; s/\^/\\^/g')/d" "$file" || true
}

ensure_shortcuts_snippet() {
  mkdir -p "${SHORTCUTS_SNIPPET:h}"
  cat > "$SHORTCUTS_SNIPPET" <<'EOS'
# PATH for macOS Shortcuts "Run Shell Script"
export PATH="$HOME/bin:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
EOS
  echo "Created Shortcuts PATH snippet: $SHORTCUTS_SNIPPET"
  echo "  In Shortcuts 'Run Shell Script', add as first line:"
  echo "    source \"$SHORTCUTS_SNIPPET\""
}

ensure_brew() {
  if command -v brew >/dev/null 2>&1; then
    return 0
  elif [[ -x /opt/homebrew/bin/brew ]]; then
    eval "$(/opt/homebrew/bin/brew shellenv)" || true
    rehash_safely; return 0
  elif [[ -x /usr/local/bin/brew ]]; then
    eval "$(/usr/local/bin/brew shellenv)" || true
    rehash_safely; return 0
  fi
  echo "Homebrew not found — installing Homebrew..."
  NONINTERACTIVE=1 /bin/bash -c \
    "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
  if [[ -x /opt/homebrew/bin/brew ]]; then
    eval "$(/opt/homebrew/bin/brew shellenv)"
  elif [[ -x /usr/local/bin/brew ]]; then
    eval "$(/usr/local/bin/brew shellenv)"
  fi
  rehash_safely
  command -v brew >/dev/null 2>&1 || die "brew installation appears to have failed"
}

ensure_podman() {
  if ! command -v podman >/dev/null 2>&1; then
    echo "Installing Podman with Homebrew…"
    brew list podman >/dev/null 2>&1 || brew install podman
    rehash_safely
  fi
  command -v podman >/dev/null 2>&1 || die "podman not found after installation"
}

ensure_podman_machine() {
  if ! podman machine inspect "$MACHINE" >/dev/null 2>&1; then
    echo "Creating Podman machine '$MACHINE' (cpus=$PODMAN_CPUS, mem=${PODMAN_MEM}MB, disk=${PODMAN_DISK}GB)…"
    podman machine init \
      --cpus "$PODMAN_CPUS" \
      --memory "$PODMAN_MEM" \
      --disk-size "$PODMAN_DISK" \
      "$MACHINE"
  else
    echo "Podman machine '$MACHINE' already exists."
  fi
}

remove_podman_machine() {
  if command -v podman >/dev/null 2>&1; then
    if podman machine inspect "$MACHINE" >/dev/null 2>&1; then
      echo "Removing Podman machine '$MACHINE'…"
      podman machine stop "$MACHINE" >/dev/null 2>&1 || true
      podman machine rm -f "$MACHINE" >/dev/null 2>&1 || true
    fi
  fi
}

link_into_bin() {
  local src="$1" base link
  base="${src:t}"
  link="$BIN/$base"
  ln -sf "$src" "$link"
  printf '%s\t%s\n' "$link" "$src" >> "$tmp_manifest"
  echo "  + linked $base"
}

generate_wrappers() {
  echo "Repo:            $REPO_DIR"
  echo "Scan root:       $FILES_DIR"
  echo "Wrappers out:    $WRAPPERS_DIR"
  rm -rf "$WRAPPERS_DIR"
  mkdir -p "$WRAPPERS_DIR"

  typeset -A used_names
  local index_file="${WRAPPERS_DIR}/index.tsv"
  : > "$index_file"

make_name() {
  local cf="$1"
  local base="${cf:t}"
  local dir="${cf:h:t}"      # parent directory name
  local stem slug out i=2

  case "${base:l}" in
    containerfile|dockerfile)
      # Canonical filename: use the directory as the service name
      stem="$dir"
      ;;
    *)
      # Use the file stem with common suffixes stripped
      stem="$base"
      stem="${stem%.Containerfile}"; stem="${stem%.containerfile}"
      stem="${stem%.Dockerfile}";    stem="${stem%.dockerfile}"
      stem="${stem%.*}"
      [[ -z "$stem" ]] && stem="$dir"
      ;;
  esac

  # Slug: lowercase, keep [a-z0-9._-], compress/trim dashes
  slug="${(L)stem//[^a-z0-9._-]/-}"
  slug="${slug##-}"; slug="${slug%%-}"
  [[ -z "$slug" ]] && slug="${(L)dir}"

  out="$slug"
  while [[ -n "${used_names[$out]:-}" || -e "$WRAPPERS_DIR/$out" ]]; do
    out="${slug}-${i}"
    (( i++ ))
  done
  used_names[$out]=1
  print -r -- "$out"
}

  local cf name abs wrapper rel
  for cf in \
    "$FILES_DIR"/**/Containerfile(.N) "$FILES_DIR"/**/*.Containerfile(.N) "$FILES_DIR"/**/*.containerfile(.N) \
    "$FILES_DIR"/**/Dockerfile(.N)    "$FILES_DIR"/**/*.Dockerfile(.N)    "$FILES_DIR"/**/*.dockerfile(.N)
  do
    [[ -f "$cf" ]] || continue
    name="$(make_name "$cf")"
    abs="${cf:A}"
    wrapper="${WRAPPERS_DIR}/${name}"
    rel="${cf:h}/release.yaml"
    rel="${rel:A}"

    if [[ -f "$rel" ]]; then
cat > "$wrapper" <<EOF
#!/bin/zsh
set -euo pipefail
# Auto-generated wrapper. Invokes 'dr' against a specific build file.
export DR_WRAPPER_NAME="${name}"
exec dr "${abs}" "${rel}" "\$@"
EOF
    else
cat > "$wrapper" <<EOF
#!/bin/zsh
set -euo pipefail
# Auto-generated wrapper. Invokes 'dr' against a specific build file.
export DR_WRAPPER_NAME="${name}"
exec dr "${abs}" "\$@"
EOF
    fi

    chmod +x "$wrapper"

    printf '%s\t%s\n' "$name" "$abs" >> "$index_file"
    echo "  + ${name} -> ${abs}"
  done

  echo "Wrote index: $index_file"
  echo "Done generating wrappers."
}

install_all() {
  # Require OSXBIN_DIR and dr
  [[ -d "$OSXBIN_DIR" ]] || die "required directory missing: $OSXBIN_DIR (must contain 'dr')"
  [[ -f "$OSXBIN_DIR/dr" ]] || die "required tool missing: $OSXBIN_DIR/dr"
  chmod +x "$OSXBIN_DIR/dr" 2>/dev/null || true

  mkdir -p "$BIN" "$LA_DIR"

  # 0) Ensure ~/bin in PATH + Shortcuts snippet
  add_path_block "$HOME/.zprofile"
  add_path_block "$HOME/.zshrc"
  ensure_shortcuts_snippet

  # 0.5) Ensure brew & podman & machine
  ensure_brew
  ensure_podman
  ensure_podman_machine

  # 1) Copy helper scripts into ~/bin
  [[ -f "$SCRIPT_DIR/pmachine-waker" ]] || die "missing pmachine-waker next to this script"
  install -m 0755 "$SCRIPT_DIR/pmachine-waker" "$BIN/pmachine-waker"

  # 2) Prepare plists
  [[ -f "$PLIST_WAKER_SRC" ]] || die "missing $PLIST_WAKER_SRC"
  sed -e "s|%UID%|$UID_NUM|g" -e "s|\${HOME}|$HOME|g" "$PLIST_WAKER_SRC" > "$PLIST_WAKER_DST"

  # 3) (Re)load LaunchAgents
  launchctl bootout   "gui/$UID_NUM" "$PLIST_WAKER_DST" >/dev/null 2>&1 || true
  launchctl bootstrap "gui/$UID_NUM" "$PLIST_WAKER_DST"

  echo "Loaded LaunchAgents."
  echo "Socket: /tmp/pmachine.$UID_NUM.sock (owned by launchd)."

  # 4) Generate wrappers
  generate_wrappers

  # 5) Install symlinks (wrappers + tools) tracked by manifest
  echo "Installing wrappers from: $WRAPPERS_DIR"
  echo "Installing tools from:    $OSXBIN_DIR"
  echo "Target bin dir:           $BIN"

  tmp_manifest="$(mktemp "${MANIFEST}.XXXXXX")"
  trap 'rm -f "$tmp_manifest"' EXIT

  if [[ -f "$MANIFEST" ]]; then
    while IFS=$'\t' read -r link target; do
      [[ -n "$link" ]] || continue
      if [[ -L "$link" ]]; then
        local cur; cur="$(readlink "$link")"
        if [[ "$cur" == "$WRAPPERS_DIR"* || "$cur" == "$OSXBIN_DIR"* || ! -e "$cur" ]]; then
          rm -f "$link"
          echo "  - removed old $link"
        fi
      fi
    done < <(sed -e $'s/\\\\t/\t/g' "$MANIFEST")
  fi

  # Link generated wrappers (regular executable files only)
  local w
  for w in "$WRAPPERS_DIR"/*(.xN); do
    link_into_bin "$w"
  done

  # Link top-level tools from OSXBIN_DIR, but never the lib dir
  for w in "$OSXBIN_DIR"/*(.xN); do
    [[ "${w:t}" == "lib" ]] && continue
    link_into_bin "$w"
  done

  # 5b) Install libraries: make $BIN/lib a real dir, then link files from $OSXBIN_DIR/lib
  if [[ -d "$OSXBIN_DIR/lib" ]]; then
    # If a previous bad install left $BIN/lib as a symlink, remove it
    if [[ -L "$BIN/lib" ]]; then
      echo "  ~ removing old symlink at $BIN/lib"
      rm -f "$BIN/lib"
    fi
    mkdir -p "$BIN/lib"

    local f rel dest
    # Link all regular files recursively, preserving subdirs
    for f in "$OSXBIN_DIR"/lib/**/*(.N); do
      rel="${f#${OSXBIN_DIR}/lib/}"
      dest="$BIN/lib/$rel"
      mkdir -p "${dest:h}"
      ln -sf "$f" "$dest"
      printf '%s\t%s\n' "$dest" "$f" >> "$tmp_manifest"
      echo "  + linked lib/${rel}"
    done
  fi

  mv -f "$tmp_manifest" "$MANIFEST"
  trap - EXIT
  echo "Wrote manifest: $MANIFEST"

  case ":$PATH:" in
    *":$BIN:"*) echo "'dr' is installed at $BIN/dr and is already in your PATH for this shell." ;;
    *) echo "'dr' is installed at $BIN/dr, but your current shell won't see it until you open a new session."
       echo "  For this shell only, run: export PATH=\"\$HOME/bin:\$PATH\"" ;;
  esac

  echo "Install complete."
  echo "For macOS Shortcuts, at the top of your 'Run Shell Script' action add:"
  echo "  source \"$SHORTCUTS_SNIPPET\""
}

uninstall_all() {
  echo "Uninstalling EVERYTHING this script installed…"

  if [[ -f "$MANIFEST" ]]; then
    echo "Removing symlinks listed in: $MANIFEST"
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      local line_fixed link target cur
      line_fixed="${line//\\t/$'\t'}"
      if [[ "$line_fixed" == *$'\t'* ]]; then
        link="${line_fixed%%$'\t'*}"
        target="${line_fixed#*$'\t'}"
      else
        continue
      fi
      [[ -n "$link" ]] || continue
      if [[ -L "$link" ]]; then
        cur="$(readlink "$link")"
        if [[ "$cur" == "$target" || "$cur" == "$WRAPPERS_DIR"* || "$cur" == "$OSXBIN_DIR"* || ! -e "$cur" ]]; then
          rm -f "$link"
          echo "  - removed $link"
        else
          echo "  ~ skipped $link (retargeted to $cur)"
        fi
      elif [[ -e "$link" ]]; then
        echo "  ~ skipped $link (exists but is not a symlink)"
      fi
    done < "$MANIFEST"
    rm -f "$MANIFEST"
    echo "Removed manifest."
  else
    echo "No manifest found—continuing."
  fi

  if [[ -d "$WRAPPERS_DIR" ]]; then
    echo "Deleting generated wrappers directory: $WRAPPERS_DIR"
    rm -rf "$WRAPPERS_DIR"
  fi

  for label in "$LABEL_WAKER"; do
    plist="$LA_DIR/$label.plist"
    launchctl bootout "gui/$UID_NUM" "$plist" >/dev/null 2>&1 || true
    rm -f "$plist"
  done

  rm -f "$BIN/pmachine-waker"

  local sock="/tmp/pmachine.$UID_NUM.sock"
  [[ -S "$sock" ]] && rm -f "$sock" || true

  if [[ -f "$SHORTCUTS_SNIPPET" ]]; then
    rm -f "$SHORTCUTS_SNIPPET"
    rmdir -p "${SHORTCUTS_SNIPPET:h}" 2>/dev/null || true
    echo "Removed Shortcuts PATH snippet."
  fi

  remove_path_block "$HOME/.zprofile"
  remove_path_block "$HOME/.zshrc"

  remove_podman_machine

  echo "Uninstall complete."
}

# ---- Main -----------------------------------------------------------------------
if (( $# == 1 )) && [[ "$1" == "--uninstall" ]]; then
  uninstall_all
elif (( $# == 0 )); then
  install_all
else
  cat <<USAGE >&2
Usage:
  $0                 Install activation + generate wrappers + install symlinks + brew/podman/machine
  $0 --uninstall     Remove EVERYTHING this script installed (incl. Podman machine)
USAGE
  exit 2
fi
