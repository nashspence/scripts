#!/bin/sh
# podman-machine-agent — socket-activated; starts VM, holds while connected,
# stops if last client disconnects

set -eu
[ "${DEBUG:-}" ] && set -x

# --- PATH (homebrew first), then system -----------------------------------
PATH="$HOME/bin:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
export PATH

# --- deps ------------------------------------------------------------------
command -v podman >/dev/null 2>&1 || { printf '%s\n' 'podman not found' >&2; exit 127; }

# --- Config (globals needed by traps) -------------------------------------
MACHINE=${MACHINE:-com.nashspence.scripts}

# Guard against REPO_DIR being unset under `set -u`
_repo_root=${REPO_DIR:-$HOME}

STATE_DIR=${STATE_DIR:-${_repo_root}/osx/launch-agents/podman-machine/data}
HOLDS_DIR=${HOLDS_DIR:-$STATE_DIR/holds}

STOP_GRACE_SECS=${STOP_GRACE_SECS:-1}
QUIESCE_MS=${QUIESCE_MS:-1500}      # watch briefly for back-to-back clients
WAIT_TIMEOUT_SECS=${WAIT_TIMEOUT_SECS:-90}

log() {
  printf '%s podman-machine-agent[%s]: %s\n' "$(date '+%F %T')" "$$" "$*"
}

gc_holds() {
  for f in "$HOLDS_DIR"/*; do
    [ -e "$f" ] || continue
    pid=${f##*/}
    case $pid in
      ''|*[!0-9]*) rm -f "$f" 2>/dev/null ;;
      *) kill -0 "$pid" 2>/dev/null || rm -f "$f" 2>/dev/null ;;
    esac
  done
}

count_holds() {
  set -- "$HOLDS_DIR"/*
  [ -e "$1" ] || set --
  printf '%s\n' "$#"
}

wait_podman_ready() {
  start=$(date +%s)
  while :; do
    if podman --connection "$MACHINE" info >/dev/null 2>&1; then
      return 0
    fi
    sleep 0.5
    now=$(date +%s)
    if [ $((now - start)) -ge "$WAIT_TIMEOUT_SECS" ]; then
      log "timeout waiting for podman '$MACHINE'"
      return 1
    fi
  done
}

# --- Main ------------------------------------------------------------------
mkdir -p "$HOLDS_DIR"
gc_holds

# Register a hold file (global path so traps can see it after `main` returns)
HOLD_FILE="$HOLDS_DIR/$$"
printf '%s\n' "$$" > "$HOLD_FILE"

cleanup_hold() {
  rm -f "$HOLD_FILE" 2>/dev/null || true
}
trap cleanup_hold EXIT TERM HUP INT

log "connection accepted; ensuring machine '$MACHINE' is running"
podman machine start "$MACHINE" >/dev/null 2>&1 || true
wait_podman_ready || true

# Notify the client that the machine is ready, then block until it disconnects
printf 'ready\n'
cat >/dev/null || true

# Client disconnected — debounce, then quiesce-watch for a short window
cleanup_hold
[ "$STOP_GRACE_SECS" -gt 0 ] && sleep "$STOP_GRACE_SECS"

gc_holds
loops=$((QUIESCE_MS / 100))
i=0
while [ "$i" -lt "$loops" ]; do
  if [ "$(count_holds)" != 0 ]; then
    log "new connection arrived during quiesce; leaving machine running"
    exit 0
  fi
  sleep 0.1
  i=$((i + 1))
done

log "no connections after quiesce; stopping machine '$MACHINE'"
podman machine stop "$MACHINE" >/dev/null 2>&1 || true
exit 0
