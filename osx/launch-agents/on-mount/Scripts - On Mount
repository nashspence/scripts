#!/bin/zsh
emulate -L zsh
set -eu
set -o pipefail
setopt EXTENDED_GLOB NULL_GLOB

marker=".com.nashspence.scripts.on-mount.id"
onmount_dir="${HOME}/On Mount"

base="$(cd "$(dirname "$0")" && pwd)"
data="${base}/data"
state="${data}/state.tsv"
tmp_state="${state}.new"
lock="${HOME}/Library/Caches/com.nashspence.scripts.on-mount.lock"

ts()    { /bin/date '+%Y-%m-%d %H:%M:%S%z'; }
log()   { print -r -- "[$(ts)] $*"; }
warn()  { print -u2 -r -- "[$(ts)] $*"; }

umask 077
mkdir -p "${data}"
[ -e "${state}" ] || : >| "${state}"

if ! mkdir "${lock}" 2>/dev/null; then
  warn "Another instance appears to be running (lock: ${lock}). Exiting."
  exit 0
fi
trap 'rm -f "${tmp_state}" 2>/dev/null || true; rmdir "${lock}" 2>/dev/null || true' EXIT

rm -f -- ${state}*.new(N) 2>/dev/null || true
: >| "${tmp_state}"

# Small settle so /Volumes reflects mounts/unmounts when triggered by WatchPaths
sleep 0.2

log "Starting on-mount scan (base=${base})"
[[ -d "${onmount_dir}" ]] || { warn "Action directory not found: ${onmount_dir}. Nothing to execute."; exit 0; }

get_prev_devid() {
  local volname="$1"
  /usr/bin/awk -F '\t' -v v="$volname" '$1==v {print $2; exit}' "${state}" 2>/dev/null || true
}

get_devid() {
  local vol="$1" id=""
  id=$(/usr/sbin/diskutil info -plist "$vol" 2>/dev/null | /usr/bin/plutil -extract VolumeUUID raw -o - - 2>/dev/null || true)
  [[ -n $id ]] || id=$(/usr/sbin/diskutil info -plist "$vol" 2>/dev/null | /usr/bin/plutil -extract APFSVolumeUUID raw -o - - 2>/dev/null || true)
  [[ -n $id ]] || id=$(/usr/bin/stat -f '%d' "$vol" 2>/dev/null || true)
  print -r -- "$id"
}

typeset -i ran=0
typeset -a actions

# PASS 1: compute new state (ONLY currently mounted + marked volumes)
for vol in /Volumes/*(/N); do
  [[ -d $vol ]] || continue
  volname=${vol:t}
  file="${vol%/}/${marker}"
  [[ -r $file ]] || continue

  devid="$(get_devid "$vol")"
  [[ -n $devid ]] || { warn "Could not read device id for ${volname}"; continue; }

  prev="$(get_prev_devid "$volname")"

  # record current state
  /usr/bin/printf '%s\t%s\n' "$volname" "$devid" >> "${tmp_state}"

  # queue action if changed and executable exists
  name=""
  IFS= read -r name < "$file" || name=""
  name="${name//$'\r'/}"
  name="${name:t}"
  if [[ "$prev" != "$devid" && -n "$name" ]]; then
    prog="${onmount_dir%/}/${name}"
    [[ -f "${prog}" && -x "${prog}" ]] && actions+=("${prog}" "$vol" "$volname") \
      || warn "No executable named \"${name}\" in ${onmount_dir} (missing or not executable); skipping ${volname}."
  fi
done

# ALWAYS commit the new snapshot (prunes stale entries on unmount)
mv -f "${tmp_state}" "${state}"
log "State updated: $(/usr/bin/wc -l < "${state}" 2>/dev/null | xargs) entries."

# PASS 2: run queued actions
integer i=1
while (( i <= ${#actions} )); do
  prog="${actions[i]}" ; vol="${actions[i+1]}" ; volname="${actions[i+2]}"
  log "Executing \"${prog}\" for \"${volname}\""
  "${prog}" "$vol" || { sc=$?; warn "Executable exited with status ${sc} for \"${volname}\""; }
  (( ran++ ))
  (( i += 3 ))
done

log "Done. Triggered ${ran} time(s)."