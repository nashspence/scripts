#!/bin/sh
# use-machine — keep the Podman machine awake while a process runs.
# Usage: use-machine pid
#
# - Prints the machine name once the agent signals "ready"
# - Keeps the agent connection open (no EOF) for the lifetime of the given PID
# - Detaches background watcher stdio so $(...) doesn’t hang

set -eu
[ "${DEBUG:-}" ] && set -x

if [ "$#" -ne 1 ]; then
    echo "usage: use-machine pid" >&2
    exit 2
fi

pid=$1
case "$pid" in
    ''|*[!0-9]*) echo "invalid pid: $pid" >&2; exit 2 ;;
esac

command -v nc >/dev/null 2>&1 || { echo "nc not found" >&2; exit 127; }

uid=$(id -u)
machine="${USE_MACHINE_NAME:-${MACHINE:-com.nashspence.use-machine}}"
sock="${USE_MACHINE_SOCKET:-${PODMAN_SOCK:-/tmp/${machine}.podman-machine.${uid}.sock}}"

# FIFO used to read a single readiness line from the agent.
ready_fifo=$(mktemp "${TMPDIR:-/tmp}/use-machine.ready.XXXXXX")
rm -f "$ready_fifo"
mkfifo "$ready_fifo"

# FIFO whose write end we hold open so the agent never sees EOF until $pid exits.
hold_fifo=$(mktemp "${TMPDIR:-/tmp}/use-machine.hold.XXXXXX")
rm -f "$hold_fifo"
mkfifo "$hold_fifo"

# Background watcher: open the hold FIFO for writing and keep it open while $pid lives.
# Detach stdio so command substitution doesn't block.
(
    exec </dev/null >/dev/null 2>&1
    # Keep the write end open on FD 8 (never write; just keep it open).
    exec 8>"$hold_fifo"
    while kill -0 "$pid" 2>/dev/null; do
        sleep 15 || break
    done
    # Exiting closes FD 8, which will propagate EOF to nc's stdin.
    :
) &
watcher_pid=$!

# Connect to the agent socket:
#  - stdout -> ready_fifo (to capture the "ready" line)
#  - stdin  -> hold_fifo  (remains open so the agent's `cat` never gets EOF)
nc -U "$sock" >"$ready_fifo" <"$hold_fifo" 2>/dev/null &
sock_pid=$!

# If we die early, clean up children and FIFOs.
trap 'kill "$sock_pid" "$watcher_pid" 2>/dev/null || true; rm -f "$ready_fifo" "$hold_fifo" 2>/dev/null || true' 0 2 15

# Wait for the agent to confirm readiness.
if ! IFS= read -r _ <"$ready_fifo"; then
    rm -f "$ready_fifo" "$hold_fifo"
    wait "$sock_pid" 2>/dev/null || true
    kill "$watcher_pid" 2>/dev/null || true
    exit 1
fi
rm -f "$ready_fifo"

# If nc already died, bail (socket not held).
if ! kill -0 "$sock_pid" 2>/dev/null; then
    wait "$sock_pid" 2>/dev/null || true
    kill "$watcher_pid" 2>/dev/null || true
    rm -f "$hold_fifo"
    exit 1
fi

# From here, the watcher holds the connection open by keeping the FIFO writer alive.
# When $pid exits, the watcher exits, closing the FIFO writer -> EOF to nc stdin
# -> agent's `cat` exits -> agent quiesces/stops machine if no other holds exist.

# The watcher owns lifecycle; just ensure the hold FIFO path is cleaned up on our exit.
trap 'rm -f "$hold_fifo" 2>/dev/null || true' 0 2 15

# Print the machine name so command substitution returns immediately.
printf '%s\n' "$machine"
exit 0
